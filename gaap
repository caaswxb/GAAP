#! /usr/bin/perl -w

use strict;
use Getopt::Long;
use Data::Dumper;
use File::Basename;
use FindBin qw ($RealBin);

my $task = 'gaap';
my $mode = 0;

my $pipeline     = 'pipe' ;
my $basic        = 'stat' ;
my $bkp          = 'bkp' ;
my $correction   = 'crct' ;
my $completeness = 'comp' ;
my $redun        = 'redun';
my $command      =  shift ;

my $usage = qq(
  Program: gaap
  Version: V1.0
  
  Pipeline to assess genome assembly.
  
  Usage:   gaap <command> [options]
  Command: stat       report genome basic information
           macc       base accuracy based on reads mapping 
           bkp        breakpoints number detected
           snvcov     SNV-coverage dot plot
           busco      run busco
);

die $usage unless $command;

##------------------------------------main------------------------------------##
if ( $command eq 'pipe' ) {
	
}elsif ( $command eq 'stat' ) {
	system "$RealBin/scripts/basic.pl @ARGV" and die "[$task] Running error with $RealBin/scripts/basic.pl.\n";
}elsif ( $command eq 'macc' ) {
	system "$RealBin/scripts/stat_accuracy_base.pl @ARGV" and die "[$task] Running error with $RealBin/scripts/stat_accuracy_base.pl.\n";
}elsif ( $command eq 'bkp' ) {
	system "$RealBin/scripts/breakpoint_detected.pl @ARGV" and die "[$task] Running error with $RealBin/scripts/breakpoint_detected.pl.\n";
}elsif ( $command eq 'snvcov' ) {
	system "$RealBin/scripts/cov_snp_dot.pl @ARGV" and die "[$task] Running error with $RealBin/scripts/cov_snp_dot.pl.\n";
}elsif ( $command eq 'busco' ) {
	system "$RealBin/scripts/run_busco.pl @ARGV" and die "[$task] Running error with $RealBin/scripts/run_busco.pl.\n";
}else {
	die "[$task] Error! Unrecognized command: $command.\n", $usage;
}

##---------------------------------subroutine---------------------------------##
#sub parse_conf {
#	my $conf_file = shift;
#	open CONF, '<', $conf_file or die "Can't open config file: $conf_file.\n";
#	while (<CONF>) {
#		chomp;
#		next if /^#/;
#		my ($parameter, $value) = split /=/, $_;
#		next if !$value || $value =~ /^\s*$/;
#		$parameter =~ s/^\s+//;
#		$parameter =~ s/\s+$//;
#		$value =~ s/^\s+//;
#		$value =~ s/\s+$//;
#		die "[$task] Parse config file error! Make sure there's no space in path.\n" if $value =~ /\s+/;
#		$conf{$parameter} = $value;
#	}
#	%conf ? return %conf : die "[$task] Error! No value has been found in config file.\n";
#}

sub _system {
	my $cmd = shift;
	my $mode = shift if @_;
	if ( $mode == 1 ) {
		print $cmd,"\n";
	}else {
		print $cmd,"\n";
		die "[$task] Can't run \"$cmd\".\n" if ( system $cmd );
	}
	return;
}

sub check_software {
	my $software = shift;
	my $path = shift if @_;
	if ( $path ) {
		if ( basename($path) eq "software" && -X $path ) {
			$software = $path;
		}else {
			return "1";
		}
	}else {
		my @path = split /:/, $ENV{PATH};
		foreach ( @path ) {
			$_ =~ s/\/$//; 
			return $software = "$_/$software" if -X "$_/$software";
		}
		return "1";
	}
}


__END__

##DATA
#TGS reads
 TGS_reads=
#TGS BAM
 TGS_BAM=
#NGS reads
 NGS_reads1=
 NGS_reads2=
 NGS_reads1.2=
 NGS_reads2.2=
#NGS BAM
 NGS_BAM_path=
#RNA seq
 RNA_seq_reads1=
 RNA_seq_reads2=
 
##SOFTWARE(path to executable file)
#samtools
 path_to_samtools=
#bwa 
 path_to_bwa=
#hisat2
 path_to_hisat2=
#minimap2
 path_to_minimap2=
#bcftools
 path_to_bcftools=
 
